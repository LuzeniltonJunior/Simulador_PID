
//	TITULO:	SIMULADOR DE SISTEMA DE 1A ORDEM COM CONTROLE PID E SUAVIZACAO/ATRASO VIA MEDIA MOVEL
//	AUTOR:	ENG. LUZENILTON TORRES
//	DATA:	18/09/2024
//	VERSAO:	1.1.4


VAR_GLOBAL:
	LIGA_SISTEMA	Bit				
	FLUXO_VAPOR	FLOAT [Single Precision]
	VAZAMENTO	FLOAT [Single Precision]
	CONST_TEMPO	FLOAT [Single Precision]	
	P_MAX		FLOAT [Single Precision]	
	T_AMOST_PID	FLOAT [Single Precision]					
	MV		FLOAT [Single Precision]	
	P_SAIDA		FLOAT [Single Precision]	
	ERRO		FLOAT [Single Precision]	
	SP		FLOAT [Single Precision]	
	PV		FLOAT [Single Precision]	
	KP		FLOAT [Single Precision]	
	TI		FLOAT [Single Precision]	
	TD		FLOAT [Single Precision]	
	ATRASO_SENSOR	FLOAT [Single Precision]	
	FATOR_CONSUMO	FLOAT [Single Precision]	



VAR_LOCAL:
	TEMPO_DE_SCAN		FLOAT [Single Precision]	
	DELTA_T			FLOAT [Single Precision]	
	TAU			FLOAT [Single Precision]	
	P_ENTRADA		FLOAT [Single Precision]	
	ABERTURA_VALVULA	FLOAT [Single Precision]	
	DISSIPACAO		FLOAT [Single Precision]	
	P_T0			FLOAT [Single Precision]	
	CONSUMINDO		FLOAT [Single Precision]	
	INTEGRAL		FLOAT [Single Precision]
	ACC_MEDIA_MOVEL		FLOAT [Single Precision]
	TIME_PID		FLOAT [Single Precision]	
	DERIVADA		FLOAT [Single Precision]	
	ERRO_ANTERIOR		FLOAT [Single Precision]
	AUX			FLOAT [Single Precision]
	CONSUMO_ALEATORIO	FLOAT [Single Precision]
	TAMANHO_BUFFER		FLOAT [Single Precision]	
	VETOR_VALORES		FLOAT [Single Precision](0..999)
	CONTAGEM		Word [Unsigned]/Bit String [16-bit]
	ALEATORIO		Word [Unsigned]/Bit String [16-bit]
	TEMPO_ATRASO		Word [Unsigned]/Bit String [16-bit]
	LOOP_PID		TON	
	T_MEDIA_MOVEL		TON
	TIMER_CONSUMO		TON	
	TIMER_SEM_CONSUMO	TON
	TEMPO_CONSUMINDO	Time	
	TEMPO_SEM_CONSUMIR	Time
	LOOP_T			Time
	BUFFER_CIRCULAR		Bit	
	CALCULA_ALEATORIOS	Bit	
	CONSUMIR		Bit	
	CALC_CONSUMO		F_TRIG	



/////////////////////////////////////////////////////////////////////////////////////////
//				SISTEMA DE PRIMEIRA ORDEM
////////////////////////////////////////////////////////////////////////////////////////

//PEGA O SCAN DO PLC E CONVERTE PARA SEGUNDOS
TEMPO_DE_SCAN := SD520;
IF TEMPO_DE_SCAN < 1 THEN
	TEMPO_DE_SCAN := 1;
END_IF;

DELTA_T := TEMPO_DE_SCAN/1000;

//CONSTANTE DE TEMPO
TAU := CONST_TEMPO + VAZAMENTO;

//SIMULACAO DO SISTEMA
IF LIGA_SISTEMA THEN  
		
	//PEGA A ABERTURA DA VALVULA (SAIDA DO PID)   
	MV := ABERTURA_VALVULA;
	
	//CALCULA A PRESSAO DE ENTRADA
	P_ENTRADA := (MV/100.0)*P_MAX*(FLUXO_VAPOR/100.0);
	
	//EQUACAO DO SISTEMA
	P_SAIDA := P_T0 + (DELTA_T/TAU)*(P_ENTRADA-P_SAIDA) - DISSIPACAO;
	
	//ATUALIZA OS INSTANTES
	P_T0	:= P_SAIDA;
	
	IF P_T0 < 0 THEN
		P_T0 := 0;
	END_IF;
	
	//DISSIPACAO DE ENERGIA (PRA SIMULAR UNS PEQUENOS VAZAMENTOS E FICAR MAIS REAL):
	DISSIPACAO :=	(1/(P_MAX*P_SAIDA+1000))
	*(FLUXO_VAPOR/100)
	*CONSUMINDO; //SIMULA O CONSUMO PELOS EQUIPAMENTOS
					
	IF P_SAIDA <= 0 THEN
		P_SAIDA := 0;
	END_IF;
		
	ELSE

	//RESET DE VALORES
	P_SAIDA 		:= 0.0;		//PRESSAO SAIDA
	P_T0			:= 0.0;		//PRESSAO NO INSTANTE T0
	MV			:= 0.0;		//ABERTURA DA VALVULA
	ERRO			:= 0.0;		//ERRO DO CONTROLADOR
	INTEGRAL 		:= 0.0; 	//RESET DA INTEGRAL
	LOOP_PID		(IN:=FALSE);	//DESLIGA CONTROLADOR
	T_MEDIA_MOVEL		(IN:=FALSE);	//DESLIGA O SUAVIZADOR DA PV
	BUFFER_CIRCULAR		:=FALSE;	//RESET DO BUFFER CIRCULAR
	ACC_MEDIA_MOVEL 	:= 0;		//RESET DO ACUMULADOR DA MEDIA MOVEL
	CONTAGEM		:= 0;		//RESET DO CONTADOR DE POSI AO DO VETOR
	
END_IF;


////////////////////////////////////////////////////////////////////////////
//			CONTROLE PID
////////////////////////////////////////////////////////////////////////////

//TEMPO DO LOOP PID
LOOP_T := WORD_TO_TIME(DINT_TO_WORD(REAL_TO_DINT(T_AMOST_PID)));
LOOP_PID(IN:=TRUE ,PT:= LOOP_T);

//CONVERSAO PARA SEGUNDOS EM FLOAT
TIME_PID := T_AMOST_PID/1000;
	

IF LOOP_PID.Q THEN
	
	//CALCULO DO ERRO
	ERRO := (SP - PV);
	
	//TRATA O PROBLEMA DE ARREDONDAMENTO DO HARDWARE
	IF ERRO>0 & ERRO<0.001 THEN
		ERRO := 0.001;
	END_IF;
	IF ERRO>-0.001 & ERRO<0 THEN
		ERRO := -0.001;
	END_IF;
	
	//CALCULO DA INTEGRAL
	INTEGRAL := INTEGRAL + ERRO*TIME_PID;
	
	//LIMITES DA INTEGRAL
	IF INTEGRAL > 100 THEN
		INTEGRAL := 100;
	END_IF;
	IF INTEGRAL < -100 THEN
		INTEGRAL := -100;
	END_IF;
	
	//CALCULO DA DERIVADA
	DERIVADA := (ERRO - ERRO_ANTERIOR)/TIME_PID;
	
	//CALCULO DA SAIDA O PID
	ABERTURA_VALVULA := KP*(ERRO + (1/TI)*INTEGRAL + TD*DERIVADA);
	
	//ATUALIZA O ERRO ANTERIOR
	ERRO_ANTERIOR := ERRO;
	
	//LIMITA ABERTURA DA VALVULA
	IF ABERTURA_VALVULA < 0 THEN
		ABERTURA_VALVULA := 0;
	END_IF;
	
	IF ABERTURA_VALVULA > 100 THEN
		ABERTURA_VALVULA := 100;
	END_IF;
	
	LOOP_PID(IN:=FALSE);
END_IF;


////////////////////////////////////////////////////////////////////////////
//			SIMULACAO DO CONSUMO
////////////////////////////////////////////////////////////////////////////

//DISPARA O CALCULO NA BORDA DE DESCIDA DO BIT DE CONSUMO
CALC_CONSUMO(CLK:= CONSUMIR, Q => CALCULA_ALEATORIOS);

IF CALCULA_ALEATORIOS THEN
	
	//SORTEIA UM TEMPO DE CONSUMO DE 0 A 2 SEGUNDOS
	RNDP( TRUE, ALEATORIO ); 
	AUX := ALEATORIO;
	RNDP( FALSE, ALEATORIO );
	AUX := 2000*(AUX / 32767);
	TEMPO_CONSUMINDO := WORD_TO_TIME(DINT_TO_WORD(REAL_TO_DINT(AUX)));

	//SORTEIA UM TEMPO SEM CONSUMIR DE 0 A 3 SEGUNDOS
	RNDP( TRUE, ALEATORIO ); 
	AUX := ALEATORIO;
	RNDP( FALSE, ALEATORIO );
	AUX := 3000*(AUX / 32767);
	TEMPO_SEM_CONSUMIR := WORD_TO_TIME(DINT_TO_WORD(REAL_TO_DINT(AUX)));

	//SORTEIA UM VALOR PARA CONSUMO
	RNDP( TRUE, ALEATORIO );
	AUX := ALEATORIO;
	RNDP( FALSE, ALEATORIO );
	CONSUMO_ALEATORIO := ((500 *AUX)/32767 + 1)*(FATOR_CONSUMO/100);
	
	CALCULA_ALEATORIOS := FALSE;
	
END_IF;


//ALTERNANDO OS TEMPORIZADORES DE CONSUMO
TIMER_CONSUMO(IN := CONSUMIR, PT := TEMPO_CONSUMINDO);
RST(TIMER_CONSUMO.Q, CONSUMIR);

TIMER_SEM_CONSUMO(IN := NOT(CONSUMIR), PT := TEMPO_SEM_CONSUMIR);
SET(TIMER_SEM_CONSUMO.Q, CONSUMIR);

//APLICA O CONSUMO
IF CONSUMIR THEN 
	CONSUMINDO := CONSUMO_ALEATORIO;
	IF CONSUMINDO <=0 THEN
		CONSUMINDO := 1;
	END_IF;
ELSE
	CONSUMINDO := 1;
END_IF;

	


////////////////////////////////////////////////////////////////////////////
//	 SUAVIZA  O E ATRASO DO SINAL DO SENSOR POR MEDIA MOVEL
////////////////////////////////////////////////////////////////////////////

IF ATRASO_SENSOR > 10 THEN

	//TEMPORIZADOR DE AMOSTRAGEM
	T_MEDIA_MOVEL(IN:= TRUE ,PT:= T#20ms);

	//TAMANHO DO BUFFER CIRCULAR
	TAMANHO_BUFFER :=ATRASO_SENSOR/10;

	IF T_MEDIA_MOVEL.Q THEN
	
		//DESLIGA O TEMPORIZADOR
		T_MEDIA_MOVEL(IN:= FALSE);
	
		//LIGA O BUFFER CIRCULAR
		IF BUFFER_CIRCULAR THEN
			ACC_MEDIA_MOVEL := ACC_MEDIA_MOVEL - VETOR_VALORES[CONTAGEM];
		END_IF;
	
		//ACUMULA OS K-ULTIMOS VALORES
		ACC_MEDIA_MOVEL := ACC_MEDIA_MOVEL + P_SAIDA;
	
		//SALVA OS K-ULTIMOS VALORES NO VETOR
		VETOR_VALORES[CONTAGEM] := P_SAIDA;
	
		//INCREMENTA A POSICAO DO VETOR
		CONTAGEM := CONTAGEM + 1;
	
		//SE O VETOR ENCHEU, LIGA O BUFFER CIRCULAR E VOLTA AO SEU INICIO
		IF CONTAGEM >= TAMANHO_BUFFER THEN
			SET(TRUE, BUFFER_CIRCULAR);
			CONTAGEM := 0;		
		END_IF;
	
	END_IF;

	//ATUALIZA O VALOR DO SENSOR DE PRESAO
	PV := ACC_MEDIA_MOVEL/TAMANHO_BUFFER;

ELSE

	//SE NAO HOUVER ATRASO, MANDA O SINAL DIRETO PRA PV
	PV := P_SAIDA;
	
END_IF;

/////////FIM!
											

		
		
		

